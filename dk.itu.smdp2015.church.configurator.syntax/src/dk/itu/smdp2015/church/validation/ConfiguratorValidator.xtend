/*
 * generated by Xtext
 */
package dk.itu.smdp2015.church.validation

import dk.itu.smdp2015.church.model.configurator.Binary
import dk.itu.smdp2015.church.model.configurator.Bounded
import dk.itu.smdp2015.church.model.configurator.ConfiguratorPackage
import dk.itu.smdp2015.church.model.configurator.Constraint
import dk.itu.smdp2015.church.model.configurator.Enumerated
import dk.itu.smdp2015.church.model.configurator.Expression
import dk.itu.smdp2015.church.model.configurator.InRange
import dk.itu.smdp2015.church.model.configurator.Unary
import dk.itu.smdp2015.church.model.configurator.ValueRange
import javax.inject.Inject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check

import static dk.itu.smdp2015.church.model.configurator.BinaryOperator.*
import static dk.itu.smdp2015.church.model.configurator.UnaryOperator.*

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ConfiguratorValidator extends AbstractConfiguratorValidator {

	public static val INVALID_BOUND = 'invalidBound'
	public static val INVALID_ENUMERATION = 'invalid enumeration'
	public static val INVALID_BINARYTYPE = 'invalid binary operand type'
	public static val WRONG_TYPE = "dk.itu.smdp2015.church.WrongType"

	@Inject extension ExpressionTypeProvider
	@Inject extension ExpressionValueProvider

	@Check
	def checkEnumeratedExpressionIsConstant(Enumerated it) {
		values.forEach[
			if (staticValue == null) {
				error('Enumerated item should be a constant.', ConfiguratorPackage.Literals.ENUMERATED__VALUES,
					INVALID_ENUMERATION)
			}]
	}

	@Check
	def checkBoundedExpressionUpperBoundIsConstant(Bounded bounded) {
		if (bounded.upperBound.staticValue == null) {
			error('Upper bound should be a constant.', ConfiguratorPackage.Literals.BOUNDED__UPPER_BOUND,
				INVALID_BOUND)
		}
	}

	@Check
	def checkBoundedExpressionLowerBoundIsConstant(Bounded bounded) {
		if (bounded.lowerBound.staticValue == null) {
			error('Lower bound should be a constant.', ConfiguratorPackage.Literals.BOUNDED__LOWER_BOUND,
				INVALID_BOUND)
		}
	}

	@Check
	def checkBoundedExpressionLowerIsBelowUpper(Bounded bounded) {
		val lowerVal = bounded.lowerBound?.staticValue
		val upperVal = bounded.upperBound?.staticValue
		var c = -1;
		if (lowerVal instanceof Integer && upperVal instanceof Integer) {
			c = (lowerVal as Integer).compareTo(upperVal as Integer)
		}
		if (lowerVal instanceof String && upperVal instanceof String) {
			c = (lowerVal as String).compareTo(upperVal as String)
		}
		if (lowerVal instanceof Boolean && upperVal instanceof Boolean) {
			c = (lowerVal as Boolean).compareTo(upperVal as Boolean)
		}
		if (c >= 0) {
			error('Lower bound should be less than upper bound', ConfiguratorPackage.Literals.BOUNDED__LOWER_BOUND,
				INVALID_BOUND)
		}
	}

	@Check
	def checkEnumeratedSequence(Enumerated enumerated) {
		enumerated.values.forEach[v|
			if (enumerated.values.filter[staticValue == v.staticValue].size != 1)
				error('Enumerated values should be unique',
					ConfiguratorPackage.Literals.ENUMERATED__VALUES, INVALID_BOUND)
		]
	}

	@Check
	def checkType(Constraint constraint) {
		val literal = ConfiguratorPackage.Literals.CONSTRAINT__EXPRESSION
		val type = getTypeAndCheckNotNull(constraint.expression, literal)
		checkExpectedType(type, ExpressionType.Boolean, literal)
	}

	@Check
	def checkType(Binary binary) {
		val leftLiteral = ConfiguratorPackage.Literals.BINARY__LEFT
		val rightLiteral = ConfiguratorPackage.Literals.BINARY__RIGHT
		val binaryLiteral = ConfiguratorPackage.Literals.BINARY__OPERATOR
		val leftType = getTypeAndCheckNotNull(binary.left, leftLiteral)
		val rightType = getTypeAndCheckNotNull(binary.right, rightLiteral)
		switch (binary.operator) {
			case ADDITION: {
				checkExpectedType(leftType, ExpressionType.Integer, leftLiteral)
				checkExpectedType(rightType, ExpressionType.Integer, rightLiteral)
			}
			case LOGICAL_AND: {
				checkExpectedType(leftType, ExpressionType.Boolean, leftLiteral)
				checkExpectedType(rightType, ExpressionType.Boolean, rightLiteral)
			}
			case LOGICAL_OR: {
				checkExpectedType(leftType, ExpressionType.Boolean, leftLiteral)
				checkExpectedType(rightType, ExpressionType.Boolean, rightLiteral)
			}
			case EQUAL: {
				if (leftType != rightType) {
					error("expected the same type, but the types are " + leftType + " and " + rightType, binaryLiteral,
						WRONG_TYPE)
				}
			}
			case GREATER_THAN: {
				checkExpectedType(leftType, ExpressionType.Integer, leftLiteral)
				checkExpectedType(rightType, ExpressionType.Integer, rightLiteral)
			}
			case LESS_THAN: {
				checkExpectedType(leftType, ExpressionType.Integer, leftLiteral)
				checkExpectedType(rightType, ExpressionType.Integer, rightLiteral)
			}
			case MULTIPLICATION: {
				checkExpectedType(leftType, ExpressionType.Integer, leftLiteral)
				checkExpectedType(rightType, ExpressionType.Integer, rightLiteral)
			}
			case NOT_EQUAL: {
				if (leftType != rightType) {
					error("expected the same type, but the types are " + leftType + " and " + rightType, binaryLiteral,
						WRONG_TYPE)
				}
			}
			case SUBTRACTION: {
				checkExpectedType(leftType, ExpressionType.Integer, leftLiteral)
				checkExpectedType(rightType, ExpressionType.Integer, rightLiteral)
			}
		}
	}

	@Check
	def checkType(Unary unary) {
		val innerLiteral = ConfiguratorPackage.Literals.UNARY__INNER
		val innerType = getTypeAndCheckNotNull(unary.inner, innerLiteral)
		switch (unary.operator) {
			case INVERSION: {
				checkExpectedType(innerType, ExpressionType.Integer, innerLiteral)
			}
			case LOGICAL_NOT: {
				checkExpectedType(innerType, ExpressionType.Boolean, innerLiteral)
			}
		}
	}

	@Check
	def checkType(InRange inRange) {
		val leftLiteral = ConfiguratorPackage.Literals.IN_RANGE__PARAMETER
		val rightLiteral = ConfiguratorPackage.Literals.IN_RANGE__RANGE
		val leftType = getTypeAndCheckNotNull(inRange.parameter.valueRange, leftLiteral)
		val rightType = getTypeAndCheckNotNull(inRange.range, rightLiteral)
		if (leftType != rightType) {
			error("expected the same type, but the types are " + leftType + " and " + rightType, rightLiteral,
				WRONG_TYPE)
		}
	}

	@Check
	def checkType(Enumerated range) {
		val firstType = getTypeAndCheckNotNull(range.values.get(0), ConfiguratorPackage.Literals.ENUMERATED__VALUES)
		range.values.forEach [
			val nextType = getTypeAndCheckNotNull(ConfiguratorPackage.Literals.ENUMERATED__VALUES)
			if (firstType != nextType)
				error("expected the same type, but the types are " + firstType + " and " + nextType,
					ConfiguratorPackage.Literals.ENUMERATED__VALUES, WRONG_TYPE)
		]
	}

	@Check
	def checkType(Bounded range) {
		val lowerType = getTypeAndCheckNotNull(range.lowerBound, ConfiguratorPackage.Literals.BOUNDED__LOWER_BOUND)
		val upperType = getTypeAndCheckNotNull(range.upperBound, ConfiguratorPackage.Literals.BOUNDED__UPPER_BOUND)
		if (lowerType != upperType) {
			error("expected the same type, but the types are " + lowerType + " and " + upperType,
				ConfiguratorPackage.Literals.BOUNDED__UPPER_BOUND, WRONG_TYPE)
		}
	}

	def private checkExpectedType(ExpressionType actualType, ExpressionType expectedType, EReference reference) {
		if (actualType != expectedType) {
			error("expected type " + expectedType + ", actual type is " + actualType, reference, WRONG_TYPE)
		}
	}

	def private ExpressionType getTypeAndCheckNotNull(Expression expression, EReference reference) {
		var type = expression?.typeFor
		if (type == null)
			error("unknown type", reference, WRONG_TYPE)
		type
	}

	def private ExpressionType getTypeAndCheckNotNull(ValueRange range, EReference reference) {
		var type = range?.rangeType
		if (type == null)
			error("unknown type", reference, WRONG_TYPE)
		type
	}
}
