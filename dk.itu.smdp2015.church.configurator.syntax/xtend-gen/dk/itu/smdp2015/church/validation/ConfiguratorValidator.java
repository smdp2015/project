/**
 * generated by Xtext
 */
package dk.itu.smdp2015.church.validation;

import com.google.common.base.Objects;
import dk.itu.smdp2015.church.model.configurator.Binary;
import dk.itu.smdp2015.church.model.configurator.Bounded;
import dk.itu.smdp2015.church.model.configurator.ConfiguratorPackage;
import dk.itu.smdp2015.church.model.configurator.Constant;
import dk.itu.smdp2015.church.model.configurator.Enumerated;
import dk.itu.smdp2015.church.model.configurator.Expression;
import dk.itu.smdp2015.church.validation.AbstractConfiguratorValidator;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class ConfiguratorValidator extends AbstractConfiguratorValidator {
  public final static String INVALID_BOUND = "invalidBound";
  
  public final static String INVALID_ENUMERATION = "invalid enumeration";
  
  public final static String INVALID_BINARYTYPE = "invalid binary operand type";
  
  @Check
  public void checkBinaryOperatorConstantsAreSameType(final Binary it) {
    boolean _and = false;
    boolean _and_1 = false;
    Expression _left = it.getLeft();
    Class<? extends Expression> _class = _left.getClass();
    boolean _isAssignableFrom = Constant.class.isAssignableFrom(_class);
    if (!_isAssignableFrom) {
      _and_1 = false;
    } else {
      Expression _right = it.getRight();
      Class<? extends Expression> _class_1 = _right.getClass();
      boolean _isAssignableFrom_1 = Constant.class.isAssignableFrom(_class_1);
      _and_1 = _isAssignableFrom_1;
    }
    if (!_and_1) {
      _and = false;
    } else {
      Expression _left_1 = it.getLeft();
      Class<? extends Expression> _class_2 = _left_1.getClass();
      Expression _right_1 = it.getRight();
      Class<? extends Expression> _class_3 = _right_1.getClass();
      boolean _notEquals = (!Objects.equal(_class_2, _class_3));
      _and = _notEquals;
    }
    if (_and) {
      Expression _left_2 = it.getLeft();
      Class<? extends Expression> _class_4 = _left_2.getClass();
      String _simpleName = _class_4.getSimpleName();
      Expression _right_2 = it.getRight();
      Class<? extends Expression> _class_5 = _right_2.getClass();
      String _simpleName_1 = _class_5.getSimpleName();
      String _format = String.format("Left operand (%s) should be same type as right operand (%s).", _simpleName, _simpleName_1);
      this.error(_format, ConfiguratorPackage.Literals.BINARY__LEFT, ConfiguratorValidator.INVALID_BINARYTYPE);
      Expression _right_3 = it.getRight();
      Class<? extends Expression> _class_6 = _right_3.getClass();
      String _simpleName_2 = _class_6.getSimpleName();
      Expression _left_3 = it.getLeft();
      Class<? extends Expression> _class_7 = _left_3.getClass();
      String _simpleName_3 = _class_7.getSimpleName();
      String _format_1 = String.format("Right operand (%s) should be same type as left operand (%s).", _simpleName_2, _simpleName_3);
      this.error(_format_1, ConfiguratorPackage.Literals.BINARY__RIGHT, ConfiguratorValidator.INVALID_BINARYTYPE);
    }
  }
  
  @Check
  public void checkEnumeratedExpressionIsConstant(final Enumerated it) {
    EList<Expression> _values = it.getValues();
    final Consumer<Expression> _function = new Consumer<Expression>() {
      public void accept(final Expression it) {
        Class<? extends Expression> _class = it.getClass();
        boolean _isAssignableFrom = Constant.class.isAssignableFrom(_class);
        boolean _not = (!_isAssignableFrom);
        if (_not) {
          ConfiguratorValidator.this.error("Enumerated item should be a constant.", ConfiguratorPackage.Literals.ENUMERATED__VALUES, ConfiguratorValidator.INVALID_ENUMERATION);
        }
      }
    };
    _values.forEach(_function);
  }
  
  @Check
  public void checkEnumeratedValuesAreSameType(final Enumerated it) {
    EList<Expression> _values = it.getValues();
    final Consumer<Expression> _function = new Consumer<Expression>() {
      public void accept(final Expression v) {
        Class<? extends Expression> _class = v.getClass();
        EList<Expression> _values = it.getValues();
        Expression _get = _values.get(0);
        Class<? extends Expression> _class_1 = _get.getClass();
        boolean _notEquals = (!Objects.equal(_class, _class_1));
        if (_notEquals) {
          ConfiguratorValidator.this.error("Enumerated items should have similar type.", ConfiguratorPackage.Literals.ENUMERATED__VALUES, ConfiguratorValidator.INVALID_ENUMERATION);
        }
      }
    };
    _values.forEach(_function);
  }
  
  @Check
  public void checkBoundedExpressionUpperBoundIsConstant(final Bounded bounded) {
    Expression _upperBound = bounded.getUpperBound();
    Class<? extends Expression> _class = _upperBound.getClass();
    boolean _isAssignableFrom = Constant.class.isAssignableFrom(_class);
    boolean _not = (!_isAssignableFrom);
    if (_not) {
      this.warning("Upper bound should be a constant.", ConfiguratorPackage.Literals.BOUNDED__UPPER_BOUND, ConfiguratorValidator.INVALID_BOUND);
    }
  }
  
  @Check
  public void checkBoundedExpressionSimilarBoundsType(final Bounded bounded) {
    Expression _lowerBound = bounded.getLowerBound();
    Class<? extends Expression> _class = _lowerBound.getClass();
    Expression _upperBound = bounded.getUpperBound();
    Class<? extends Expression> _class_1 = _upperBound.getClass();
    boolean _notEquals = (!Objects.equal(_class, _class_1));
    if (_notEquals) {
      this.warning("Lower and upper bound should have similar type.", ConfiguratorPackage.Literals.BOUNDED__LOWER_BOUND, ConfiguratorValidator.INVALID_BOUND);
      this.warning("Lower and upper bound should have similar type.", ConfiguratorPackage.Literals.BOUNDED__UPPER_BOUND, ConfiguratorValidator.INVALID_BOUND);
    }
  }
  
  @Check
  public void checkBoundedExpressionLowerBoundIsConstant(final Bounded bounded) {
    Expression _lowerBound = bounded.getLowerBound();
    Class<? extends Expression> _class = _lowerBound.getClass();
    boolean _isAssignableFrom = Constant.class.isAssignableFrom(_class);
    boolean _not = (!_isAssignableFrom);
    if (_not) {
      this.warning("Lower bound should be a constant.", ConfiguratorPackage.Literals.BOUNDED__LOWER_BOUND, ConfiguratorValidator.INVALID_BOUND);
    }
  }
}
